# roi-extraction-rtl-fpga-stereo_MACE
Designed and implemented two hardware-efficient Verilog architectures for real-time Region of Interest (ROI) extraction from multi-channel ADC data streams for the Stereo MACE Telescope. Integrated multiple synchronized FSMs with inter-FSM handshaking to manage latency-constrained BRAM read/write operations. Deployed and validated the RTL design on Xilinx FPGA with real-time hardware debugging using Vivado ILA, followed by a comparative performance analysis of both architectures.

Method1 - This architecture scans 120 samples per channel from BRAM1 to identify the maximum value and its address using continuous comparison logic. A fixed 30-sample ROI window (starting 15 samples before the detected peak) is then extracted and written into BRAM2. An FSM controls synchronized read/write operations and address management under deterministic latency assumptions. After ROI extraction, the design skips remaining samples and directly advances to the next channel.

Method2 - This architecture implements an event-driven ROI detection mechanism using a 5-sample sliding average as a trigger. Incoming samples from BRAM1 are processed in real time through a shift register, while simultaneously stored in a rolling dual-port BRAM buffer. When the computed average crosses a predefined threshold, sampling pauses and a 30-sample ROI (starting 5 samples before the trigger point) is extracted and written to BRAM2. The system then skips the remaining samples and advances to the next channel.

Comparitive Analysis - Edge-case evaluation showed that Method-1 struggled with noisy signals and flat/saturated peaks, leading to ambiguity in peak-based ROI selection. Method-2, using a threshold-triggered sliding average, handled noisy and saturated cases more reliably. ILA-based timing analysis indicated that Method-1 required ~2176 clock cycles for 8 channels, whereas Method-2 completed processing in ~921 clock cycles, demonstrating higher speed. However, Method-2 required manual threshold tuning and incurred higher logic utilization, while Method-1 was more resource-efficient.
